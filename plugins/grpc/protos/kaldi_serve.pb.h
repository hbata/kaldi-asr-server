// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kaldi_serve.proto

#ifndef PROTOBUF_INCLUDED_kaldi_5fserve_2eproto
#define PROTOBUF_INCLUDED_kaldi_5fserve_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_kaldi_5fserve_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_kaldi_5fserve_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_kaldi_5fserve_2eproto();
namespace kaldi_serve {
class RecognitionAudio;
class RecognitionAudioDefaultTypeInternal;
extern RecognitionAudioDefaultTypeInternal _RecognitionAudio_default_instance_;
class RecognitionConfig;
class RecognitionConfigDefaultTypeInternal;
extern RecognitionConfigDefaultTypeInternal _RecognitionConfig_default_instance_;
class RecognizeRequest;
class RecognizeRequestDefaultTypeInternal;
extern RecognizeRequestDefaultTypeInternal _RecognizeRequest_default_instance_;
class RecognizeResponse;
class RecognizeResponseDefaultTypeInternal;
extern RecognizeResponseDefaultTypeInternal _RecognizeResponse_default_instance_;
class SpeechContext;
class SpeechContextDefaultTypeInternal;
extern SpeechContextDefaultTypeInternal _SpeechContext_default_instance_;
class SpeechRecognitionAlternative;
class SpeechRecognitionAlternativeDefaultTypeInternal;
extern SpeechRecognitionAlternativeDefaultTypeInternal _SpeechRecognitionAlternative_default_instance_;
class SpeechRecognitionResult;
class SpeechRecognitionResultDefaultTypeInternal;
extern SpeechRecognitionResultDefaultTypeInternal _SpeechRecognitionResult_default_instance_;
class Word;
class WordDefaultTypeInternal;
extern WordDefaultTypeInternal _Word_default_instance_;
}  // namespace kaldi_serve
namespace google {
namespace protobuf {
template<> ::kaldi_serve::RecognitionAudio* Arena::CreateMaybeMessage<::kaldi_serve::RecognitionAudio>(Arena*);
template<> ::kaldi_serve::RecognitionConfig* Arena::CreateMaybeMessage<::kaldi_serve::RecognitionConfig>(Arena*);
template<> ::kaldi_serve::RecognizeRequest* Arena::CreateMaybeMessage<::kaldi_serve::RecognizeRequest>(Arena*);
template<> ::kaldi_serve::RecognizeResponse* Arena::CreateMaybeMessage<::kaldi_serve::RecognizeResponse>(Arena*);
template<> ::kaldi_serve::SpeechContext* Arena::CreateMaybeMessage<::kaldi_serve::SpeechContext>(Arena*);
template<> ::kaldi_serve::SpeechRecognitionAlternative* Arena::CreateMaybeMessage<::kaldi_serve::SpeechRecognitionAlternative>(Arena*);
template<> ::kaldi_serve::SpeechRecognitionResult* Arena::CreateMaybeMessage<::kaldi_serve::SpeechRecognitionResult>(Arena*);
template<> ::kaldi_serve::Word* Arena::CreateMaybeMessage<::kaldi_serve::Word>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace kaldi_serve {

enum RecognitionConfig_AudioEncoding {
  RecognitionConfig_AudioEncoding_ENCODING_UNSPECIFIED = 0,
  RecognitionConfig_AudioEncoding_LINEAR16 = 1,
  RecognitionConfig_AudioEncoding_FLAC = 2,
  RecognitionConfig_AudioEncoding_RecognitionConfig_AudioEncoding_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  RecognitionConfig_AudioEncoding_RecognitionConfig_AudioEncoding_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool RecognitionConfig_AudioEncoding_IsValid(int value);
const RecognitionConfig_AudioEncoding RecognitionConfig_AudioEncoding_AudioEncoding_MIN = RecognitionConfig_AudioEncoding_ENCODING_UNSPECIFIED;
const RecognitionConfig_AudioEncoding RecognitionConfig_AudioEncoding_AudioEncoding_MAX = RecognitionConfig_AudioEncoding_FLAC;
const int RecognitionConfig_AudioEncoding_AudioEncoding_ARRAYSIZE = RecognitionConfig_AudioEncoding_AudioEncoding_MAX + 1;

const ::google::protobuf::EnumDescriptor* RecognitionConfig_AudioEncoding_descriptor();
inline const ::std::string& RecognitionConfig_AudioEncoding_Name(RecognitionConfig_AudioEncoding value) {
  return ::google::protobuf::internal::NameOfEnum(
    RecognitionConfig_AudioEncoding_descriptor(), value);
}
inline bool RecognitionConfig_AudioEncoding_Parse(
    const ::std::string& name, RecognitionConfig_AudioEncoding* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RecognitionConfig_AudioEncoding>(
    RecognitionConfig_AudioEncoding_descriptor(), name, value);
}
// ===================================================================

class RecognizeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kaldi_serve.RecognizeRequest) */ {
 public:
  RecognizeRequest();
  virtual ~RecognizeRequest();

  RecognizeRequest(const RecognizeRequest& from);

  inline RecognizeRequest& operator=(const RecognizeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RecognizeRequest(RecognizeRequest&& from) noexcept
    : RecognizeRequest() {
    *this = ::std::move(from);
  }

  inline RecognizeRequest& operator=(RecognizeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RecognizeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecognizeRequest* internal_default_instance() {
    return reinterpret_cast<const RecognizeRequest*>(
               &_RecognizeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RecognizeRequest* other);
  friend void swap(RecognizeRequest& a, RecognizeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecognizeRequest* New() const final {
    return CreateMaybeMessage<RecognizeRequest>(nullptr);
  }

  RecognizeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RecognizeRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RecognizeRequest& from);
  void MergeFrom(const RecognizeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecognizeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string uuid = 3;
  void clear_uuid();
  static const int kUuidFieldNumber = 3;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // .kaldi_serve.RecognitionConfig config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  const ::kaldi_serve::RecognitionConfig& config() const;
  ::kaldi_serve::RecognitionConfig* release_config();
  ::kaldi_serve::RecognitionConfig* mutable_config();
  void set_allocated_config(::kaldi_serve::RecognitionConfig* config);

  // .kaldi_serve.RecognitionAudio audio = 2;
  bool has_audio() const;
  void clear_audio();
  static const int kAudioFieldNumber = 2;
  const ::kaldi_serve::RecognitionAudio& audio() const;
  ::kaldi_serve::RecognitionAudio* release_audio();
  ::kaldi_serve::RecognitionAudio* mutable_audio();
  void set_allocated_audio(::kaldi_serve::RecognitionAudio* audio);

  // @@protoc_insertion_point(class_scope:kaldi_serve.RecognizeRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::kaldi_serve::RecognitionConfig* config_;
  ::kaldi_serve::RecognitionAudio* audio_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaldi_5fserve_2eproto;
};
// -------------------------------------------------------------------

class RecognizeResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kaldi_serve.RecognizeResponse) */ {
 public:
  RecognizeResponse();
  virtual ~RecognizeResponse();

  RecognizeResponse(const RecognizeResponse& from);

  inline RecognizeResponse& operator=(const RecognizeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RecognizeResponse(RecognizeResponse&& from) noexcept
    : RecognizeResponse() {
    *this = ::std::move(from);
  }

  inline RecognizeResponse& operator=(RecognizeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RecognizeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecognizeResponse* internal_default_instance() {
    return reinterpret_cast<const RecognizeResponse*>(
               &_RecognizeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RecognizeResponse* other);
  friend void swap(RecognizeResponse& a, RecognizeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecognizeResponse* New() const final {
    return CreateMaybeMessage<RecognizeResponse>(nullptr);
  }

  RecognizeResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RecognizeResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RecognizeResponse& from);
  void MergeFrom(const RecognizeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecognizeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kaldi_serve.SpeechRecognitionResult results = 1;
  int results_size() const;
  void clear_results();
  static const int kResultsFieldNumber = 1;
  ::kaldi_serve::SpeechRecognitionResult* mutable_results(int index);
  ::google::protobuf::RepeatedPtrField< ::kaldi_serve::SpeechRecognitionResult >*
      mutable_results();
  const ::kaldi_serve::SpeechRecognitionResult& results(int index) const;
  ::kaldi_serve::SpeechRecognitionResult* add_results();
  const ::google::protobuf::RepeatedPtrField< ::kaldi_serve::SpeechRecognitionResult >&
      results() const;

  // @@protoc_insertion_point(class_scope:kaldi_serve.RecognizeResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kaldi_serve::SpeechRecognitionResult > results_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaldi_5fserve_2eproto;
};
// -------------------------------------------------------------------

class RecognitionConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kaldi_serve.RecognitionConfig) */ {
 public:
  RecognitionConfig();
  virtual ~RecognitionConfig();

  RecognitionConfig(const RecognitionConfig& from);

  inline RecognitionConfig& operator=(const RecognitionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RecognitionConfig(RecognitionConfig&& from) noexcept
    : RecognitionConfig() {
    *this = ::std::move(from);
  }

  inline RecognitionConfig& operator=(RecognitionConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RecognitionConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecognitionConfig* internal_default_instance() {
    return reinterpret_cast<const RecognitionConfig*>(
               &_RecognitionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RecognitionConfig* other);
  friend void swap(RecognitionConfig& a, RecognitionConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecognitionConfig* New() const final {
    return CreateMaybeMessage<RecognitionConfig>(nullptr);
  }

  RecognitionConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RecognitionConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RecognitionConfig& from);
  void MergeFrom(const RecognitionConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecognitionConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RecognitionConfig_AudioEncoding AudioEncoding;
  static const AudioEncoding ENCODING_UNSPECIFIED =
    RecognitionConfig_AudioEncoding_ENCODING_UNSPECIFIED;
  static const AudioEncoding LINEAR16 =
    RecognitionConfig_AudioEncoding_LINEAR16;
  static const AudioEncoding FLAC =
    RecognitionConfig_AudioEncoding_FLAC;
  static inline bool AudioEncoding_IsValid(int value) {
    return RecognitionConfig_AudioEncoding_IsValid(value);
  }
  static const AudioEncoding AudioEncoding_MIN =
    RecognitionConfig_AudioEncoding_AudioEncoding_MIN;
  static const AudioEncoding AudioEncoding_MAX =
    RecognitionConfig_AudioEncoding_AudioEncoding_MAX;
  static const int AudioEncoding_ARRAYSIZE =
    RecognitionConfig_AudioEncoding_AudioEncoding_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AudioEncoding_descriptor() {
    return RecognitionConfig_AudioEncoding_descriptor();
  }
  static inline const ::std::string& AudioEncoding_Name(AudioEncoding value) {
    return RecognitionConfig_AudioEncoding_Name(value);
  }
  static inline bool AudioEncoding_Parse(const ::std::string& name,
      AudioEncoding* value) {
    return RecognitionConfig_AudioEncoding_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .kaldi_serve.SpeechContext speech_contexts = 6;
  int speech_contexts_size() const;
  void clear_speech_contexts();
  static const int kSpeechContextsFieldNumber = 6;
  ::kaldi_serve::SpeechContext* mutable_speech_contexts(int index);
  ::google::protobuf::RepeatedPtrField< ::kaldi_serve::SpeechContext >*
      mutable_speech_contexts();
  const ::kaldi_serve::SpeechContext& speech_contexts(int index) const;
  ::kaldi_serve::SpeechContext* add_speech_contexts();
  const ::google::protobuf::RepeatedPtrField< ::kaldi_serve::SpeechContext >&
      speech_contexts() const;

  // string language_code = 3;
  void clear_language_code();
  static const int kLanguageCodeFieldNumber = 3;
  const ::std::string& language_code() const;
  void set_language_code(const ::std::string& value);
  #if LANG_CXX11
  void set_language_code(::std::string&& value);
  #endif
  void set_language_code(const char* value);
  void set_language_code(const char* value, size_t size);
  ::std::string* mutable_language_code();
  ::std::string* release_language_code();
  void set_allocated_language_code(::std::string* language_code);

  // string model = 10;
  void clear_model();
  static const int kModelFieldNumber = 10;
  const ::std::string& model() const;
  void set_model(const ::std::string& value);
  #if LANG_CXX11
  void set_model(::std::string&& value);
  #endif
  void set_model(const char* value);
  void set_model(const char* value, size_t size);
  ::std::string* mutable_model();
  ::std::string* release_model();
  void set_allocated_model(::std::string* model);

  // .kaldi_serve.RecognitionConfig.AudioEncoding encoding = 1;
  void clear_encoding();
  static const int kEncodingFieldNumber = 1;
  ::kaldi_serve::RecognitionConfig_AudioEncoding encoding() const;
  void set_encoding(::kaldi_serve::RecognitionConfig_AudioEncoding value);

  // int32 sample_rate_hertz = 2;
  void clear_sample_rate_hertz();
  static const int kSampleRateHertzFieldNumber = 2;
  ::google::protobuf::int32 sample_rate_hertz() const;
  void set_sample_rate_hertz(::google::protobuf::int32 value);

  // int32 max_alternatives = 4;
  void clear_max_alternatives();
  static const int kMaxAlternativesFieldNumber = 4;
  ::google::protobuf::int32 max_alternatives() const;
  void set_max_alternatives(::google::protobuf::int32 value);

  // int32 audio_channel_count = 7;
  void clear_audio_channel_count();
  static const int kAudioChannelCountFieldNumber = 7;
  ::google::protobuf::int32 audio_channel_count() const;
  void set_audio_channel_count(::google::protobuf::int32 value);

  // bool punctuation = 5;
  void clear_punctuation();
  static const int kPunctuationFieldNumber = 5;
  bool punctuation() const;
  void set_punctuation(bool value);

  // bool raw = 11;
  void clear_raw();
  static const int kRawFieldNumber = 11;
  bool raw() const;
  void set_raw(bool value);

  // bool word_level = 13;
  void clear_word_level();
  static const int kWordLevelFieldNumber = 13;
  bool word_level() const;
  void set_word_level(bool value);

  // int32 data_bytes = 12;
  void clear_data_bytes();
  static const int kDataBytesFieldNumber = 12;
  ::google::protobuf::int32 data_bytes() const;
  void set_data_bytes(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kaldi_serve.RecognitionConfig)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kaldi_serve::SpeechContext > speech_contexts_;
  ::google::protobuf::internal::ArenaStringPtr language_code_;
  ::google::protobuf::internal::ArenaStringPtr model_;
  int encoding_;
  ::google::protobuf::int32 sample_rate_hertz_;
  ::google::protobuf::int32 max_alternatives_;
  ::google::protobuf::int32 audio_channel_count_;
  bool punctuation_;
  bool raw_;
  bool word_level_;
  ::google::protobuf::int32 data_bytes_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaldi_5fserve_2eproto;
};
// -------------------------------------------------------------------

class RecognitionAudio final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kaldi_serve.RecognitionAudio) */ {
 public:
  RecognitionAudio();
  virtual ~RecognitionAudio();

  RecognitionAudio(const RecognitionAudio& from);

  inline RecognitionAudio& operator=(const RecognitionAudio& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RecognitionAudio(RecognitionAudio&& from) noexcept
    : RecognitionAudio() {
    *this = ::std::move(from);
  }

  inline RecognitionAudio& operator=(RecognitionAudio&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RecognitionAudio& default_instance();

  enum AudioSourceCase {
    kContent = 1,
    kUri = 2,
    AUDIO_SOURCE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecognitionAudio* internal_default_instance() {
    return reinterpret_cast<const RecognitionAudio*>(
               &_RecognitionAudio_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(RecognitionAudio* other);
  friend void swap(RecognitionAudio& a, RecognitionAudio& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecognitionAudio* New() const final {
    return CreateMaybeMessage<RecognitionAudio>(nullptr);
  }

  RecognitionAudio* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RecognitionAudio>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RecognitionAudio& from);
  void MergeFrom(const RecognitionAudio& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecognitionAudio* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes content = 1;
  private:
  bool has_content() const;
  public:
  void clear_content();
  static const int kContentFieldNumber = 1;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // string uri = 2;
  private:
  bool has_uri() const;
  public:
  void clear_uri();
  static const int kUriFieldNumber = 2;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_uri(::std::string&& value);
  #endif
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  void clear_audio_source();
  AudioSourceCase audio_source_case() const;
  // @@protoc_insertion_point(class_scope:kaldi_serve.RecognitionAudio)
 private:
  class HasBitSetters;
  void set_has_content();
  void set_has_uri();

  inline bool has_audio_source() const;
  inline void clear_has_audio_source();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union AudioSourceUnion {
    AudioSourceUnion() {}
    ::google::protobuf::internal::ArenaStringPtr content_;
    ::google::protobuf::internal::ArenaStringPtr uri_;
  } audio_source_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_kaldi_5fserve_2eproto;
};
// -------------------------------------------------------------------

class SpeechRecognitionResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kaldi_serve.SpeechRecognitionResult) */ {
 public:
  SpeechRecognitionResult();
  virtual ~SpeechRecognitionResult();

  SpeechRecognitionResult(const SpeechRecognitionResult& from);

  inline SpeechRecognitionResult& operator=(const SpeechRecognitionResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpeechRecognitionResult(SpeechRecognitionResult&& from) noexcept
    : SpeechRecognitionResult() {
    *this = ::std::move(from);
  }

  inline SpeechRecognitionResult& operator=(SpeechRecognitionResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SpeechRecognitionResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeechRecognitionResult* internal_default_instance() {
    return reinterpret_cast<const SpeechRecognitionResult*>(
               &_SpeechRecognitionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SpeechRecognitionResult* other);
  friend void swap(SpeechRecognitionResult& a, SpeechRecognitionResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpeechRecognitionResult* New() const final {
    return CreateMaybeMessage<SpeechRecognitionResult>(nullptr);
  }

  SpeechRecognitionResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SpeechRecognitionResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SpeechRecognitionResult& from);
  void MergeFrom(const SpeechRecognitionResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeechRecognitionResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kaldi_serve.SpeechRecognitionAlternative alternatives = 1;
  int alternatives_size() const;
  void clear_alternatives();
  static const int kAlternativesFieldNumber = 1;
  ::kaldi_serve::SpeechRecognitionAlternative* mutable_alternatives(int index);
  ::google::protobuf::RepeatedPtrField< ::kaldi_serve::SpeechRecognitionAlternative >*
      mutable_alternatives();
  const ::kaldi_serve::SpeechRecognitionAlternative& alternatives(int index) const;
  ::kaldi_serve::SpeechRecognitionAlternative* add_alternatives();
  const ::google::protobuf::RepeatedPtrField< ::kaldi_serve::SpeechRecognitionAlternative >&
      alternatives() const;

  // @@protoc_insertion_point(class_scope:kaldi_serve.SpeechRecognitionResult)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kaldi_serve::SpeechRecognitionAlternative > alternatives_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaldi_5fserve_2eproto;
};
// -------------------------------------------------------------------

class SpeechRecognitionAlternative final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kaldi_serve.SpeechRecognitionAlternative) */ {
 public:
  SpeechRecognitionAlternative();
  virtual ~SpeechRecognitionAlternative();

  SpeechRecognitionAlternative(const SpeechRecognitionAlternative& from);

  inline SpeechRecognitionAlternative& operator=(const SpeechRecognitionAlternative& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpeechRecognitionAlternative(SpeechRecognitionAlternative&& from) noexcept
    : SpeechRecognitionAlternative() {
    *this = ::std::move(from);
  }

  inline SpeechRecognitionAlternative& operator=(SpeechRecognitionAlternative&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SpeechRecognitionAlternative& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeechRecognitionAlternative* internal_default_instance() {
    return reinterpret_cast<const SpeechRecognitionAlternative*>(
               &_SpeechRecognitionAlternative_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(SpeechRecognitionAlternative* other);
  friend void swap(SpeechRecognitionAlternative& a, SpeechRecognitionAlternative& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpeechRecognitionAlternative* New() const final {
    return CreateMaybeMessage<SpeechRecognitionAlternative>(nullptr);
  }

  SpeechRecognitionAlternative* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SpeechRecognitionAlternative>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SpeechRecognitionAlternative& from);
  void MergeFrom(const SpeechRecognitionAlternative& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeechRecognitionAlternative* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kaldi_serve.Word words = 5;
  int words_size() const;
  void clear_words();
  static const int kWordsFieldNumber = 5;
  ::kaldi_serve::Word* mutable_words(int index);
  ::google::protobuf::RepeatedPtrField< ::kaldi_serve::Word >*
      mutable_words();
  const ::kaldi_serve::Word& words(int index) const;
  ::kaldi_serve::Word* add_words();
  const ::google::protobuf::RepeatedPtrField< ::kaldi_serve::Word >&
      words() const;

  // string transcript = 1;
  void clear_transcript();
  static const int kTranscriptFieldNumber = 1;
  const ::std::string& transcript() const;
  void set_transcript(const ::std::string& value);
  #if LANG_CXX11
  void set_transcript(::std::string&& value);
  #endif
  void set_transcript(const char* value);
  void set_transcript(const char* value, size_t size);
  ::std::string* mutable_transcript();
  ::std::string* release_transcript();
  void set_allocated_transcript(::std::string* transcript);

  // float confidence = 2;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  float confidence() const;
  void set_confidence(float value);

  // float am_score = 3;
  void clear_am_score();
  static const int kAmScoreFieldNumber = 3;
  float am_score() const;
  void set_am_score(float value);

  // float lm_score = 4;
  void clear_lm_score();
  static const int kLmScoreFieldNumber = 4;
  float lm_score() const;
  void set_lm_score(float value);

  // @@protoc_insertion_point(class_scope:kaldi_serve.SpeechRecognitionAlternative)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kaldi_serve::Word > words_;
  ::google::protobuf::internal::ArenaStringPtr transcript_;
  float confidence_;
  float am_score_;
  float lm_score_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaldi_5fserve_2eproto;
};
// -------------------------------------------------------------------

class Word final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kaldi_serve.Word) */ {
 public:
  Word();
  virtual ~Word();

  Word(const Word& from);

  inline Word& operator=(const Word& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Word(Word&& from) noexcept
    : Word() {
    *this = ::std::move(from);
  }

  inline Word& operator=(Word&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Word& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Word* internal_default_instance() {
    return reinterpret_cast<const Word*>(
               &_Word_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Word* other);
  friend void swap(Word& a, Word& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Word* New() const final {
    return CreateMaybeMessage<Word>(nullptr);
  }

  Word* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Word>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Word& from);
  void MergeFrom(const Word& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Word* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string word = 3;
  void clear_word();
  static const int kWordFieldNumber = 3;
  const ::std::string& word() const;
  void set_word(const ::std::string& value);
  #if LANG_CXX11
  void set_word(::std::string&& value);
  #endif
  void set_word(const char* value);
  void set_word(const char* value, size_t size);
  ::std::string* mutable_word();
  ::std::string* release_word();
  void set_allocated_word(::std::string* word);

  // float start_time = 1;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 1;
  float start_time() const;
  void set_start_time(float value);

  // float end_time = 2;
  void clear_end_time();
  static const int kEndTimeFieldNumber = 2;
  float end_time() const;
  void set_end_time(float value);

  // float confidence = 4;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 4;
  float confidence() const;
  void set_confidence(float value);

  // @@protoc_insertion_point(class_scope:kaldi_serve.Word)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr word_;
  float start_time_;
  float end_time_;
  float confidence_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaldi_5fserve_2eproto;
};
// -------------------------------------------------------------------

class SpeechContext final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kaldi_serve.SpeechContext) */ {
 public:
  SpeechContext();
  virtual ~SpeechContext();

  SpeechContext(const SpeechContext& from);

  inline SpeechContext& operator=(const SpeechContext& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpeechContext(SpeechContext&& from) noexcept
    : SpeechContext() {
    *this = ::std::move(from);
  }

  inline SpeechContext& operator=(SpeechContext&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SpeechContext& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeechContext* internal_default_instance() {
    return reinterpret_cast<const SpeechContext*>(
               &_SpeechContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(SpeechContext* other);
  friend void swap(SpeechContext& a, SpeechContext& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpeechContext* New() const final {
    return CreateMaybeMessage<SpeechContext>(nullptr);
  }

  SpeechContext* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SpeechContext>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SpeechContext& from);
  void MergeFrom(const SpeechContext& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeechContext* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string phrases = 1;
  int phrases_size() const;
  void clear_phrases();
  static const int kPhrasesFieldNumber = 1;
  const ::std::string& phrases(int index) const;
  ::std::string* mutable_phrases(int index);
  void set_phrases(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_phrases(int index, ::std::string&& value);
  #endif
  void set_phrases(int index, const char* value);
  void set_phrases(int index, const char* value, size_t size);
  ::std::string* add_phrases();
  void add_phrases(const ::std::string& value);
  #if LANG_CXX11
  void add_phrases(::std::string&& value);
  #endif
  void add_phrases(const char* value);
  void add_phrases(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& phrases() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_phrases();

  // string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:kaldi_serve.SpeechContext)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> phrases_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_kaldi_5fserve_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RecognizeRequest

// .kaldi_serve.RecognitionConfig config = 1;
inline bool RecognizeRequest::has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline void RecognizeRequest::clear_config() {
  if (GetArenaNoVirtual() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::kaldi_serve::RecognitionConfig& RecognizeRequest::config() const {
  const ::kaldi_serve::RecognitionConfig* p = config_;
  // @@protoc_insertion_point(field_get:kaldi_serve.RecognizeRequest.config)
  return p != nullptr ? *p : *reinterpret_cast<const ::kaldi_serve::RecognitionConfig*>(
      &::kaldi_serve::_RecognitionConfig_default_instance_);
}
inline ::kaldi_serve::RecognitionConfig* RecognizeRequest::release_config() {
  // @@protoc_insertion_point(field_release:kaldi_serve.RecognizeRequest.config)
  
  ::kaldi_serve::RecognitionConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::kaldi_serve::RecognitionConfig* RecognizeRequest::mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::kaldi_serve::RecognitionConfig>(GetArenaNoVirtual());
    config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kaldi_serve.RecognizeRequest.config)
  return config_;
}
inline void RecognizeRequest::set_allocated_config(::kaldi_serve::RecognitionConfig* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:kaldi_serve.RecognizeRequest.config)
}

// .kaldi_serve.RecognitionAudio audio = 2;
inline bool RecognizeRequest::has_audio() const {
  return this != internal_default_instance() && audio_ != nullptr;
}
inline void RecognizeRequest::clear_audio() {
  if (GetArenaNoVirtual() == nullptr && audio_ != nullptr) {
    delete audio_;
  }
  audio_ = nullptr;
}
inline const ::kaldi_serve::RecognitionAudio& RecognizeRequest::audio() const {
  const ::kaldi_serve::RecognitionAudio* p = audio_;
  // @@protoc_insertion_point(field_get:kaldi_serve.RecognizeRequest.audio)
  return p != nullptr ? *p : *reinterpret_cast<const ::kaldi_serve::RecognitionAudio*>(
      &::kaldi_serve::_RecognitionAudio_default_instance_);
}
inline ::kaldi_serve::RecognitionAudio* RecognizeRequest::release_audio() {
  // @@protoc_insertion_point(field_release:kaldi_serve.RecognizeRequest.audio)
  
  ::kaldi_serve::RecognitionAudio* temp = audio_;
  audio_ = nullptr;
  return temp;
}
inline ::kaldi_serve::RecognitionAudio* RecognizeRequest::mutable_audio() {
  
  if (audio_ == nullptr) {
    auto* p = CreateMaybeMessage<::kaldi_serve::RecognitionAudio>(GetArenaNoVirtual());
    audio_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kaldi_serve.RecognizeRequest.audio)
  return audio_;
}
inline void RecognizeRequest::set_allocated_audio(::kaldi_serve::RecognitionAudio* audio) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete audio_;
  }
  if (audio) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      audio = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, audio, submessage_arena);
    }
    
  } else {
    
  }
  audio_ = audio;
  // @@protoc_insertion_point(field_set_allocated:kaldi_serve.RecognizeRequest.audio)
}

// string uuid = 3;
inline void RecognizeRequest::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RecognizeRequest::uuid() const {
  // @@protoc_insertion_point(field_get:kaldi_serve.RecognizeRequest.uuid)
  return uuid_.GetNoArena();
}
inline void RecognizeRequest::set_uuid(const ::std::string& value) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kaldi_serve.RecognizeRequest.uuid)
}
#if LANG_CXX11
inline void RecognizeRequest::set_uuid(::std::string&& value) {
  
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kaldi_serve.RecognizeRequest.uuid)
}
#endif
inline void RecognizeRequest::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kaldi_serve.RecognizeRequest.uuid)
}
inline void RecognizeRequest::set_uuid(const char* value, size_t size) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kaldi_serve.RecognizeRequest.uuid)
}
inline ::std::string* RecognizeRequest::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:kaldi_serve.RecognizeRequest.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RecognizeRequest::release_uuid() {
  // @@protoc_insertion_point(field_release:kaldi_serve.RecognizeRequest.uuid)
  
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RecognizeRequest::set_allocated_uuid(::std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:kaldi_serve.RecognizeRequest.uuid)
}

// -------------------------------------------------------------------

// RecognizeResponse

// repeated .kaldi_serve.SpeechRecognitionResult results = 1;
inline int RecognizeResponse::results_size() const {
  return results_.size();
}
inline void RecognizeResponse::clear_results() {
  results_.Clear();
}
inline ::kaldi_serve::SpeechRecognitionResult* RecognizeResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:kaldi_serve.RecognizeResponse.results)
  return results_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kaldi_serve::SpeechRecognitionResult >*
RecognizeResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:kaldi_serve.RecognizeResponse.results)
  return &results_;
}
inline const ::kaldi_serve::SpeechRecognitionResult& RecognizeResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:kaldi_serve.RecognizeResponse.results)
  return results_.Get(index);
}
inline ::kaldi_serve::SpeechRecognitionResult* RecognizeResponse::add_results() {
  // @@protoc_insertion_point(field_add:kaldi_serve.RecognizeResponse.results)
  return results_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kaldi_serve::SpeechRecognitionResult >&
RecognizeResponse::results() const {
  // @@protoc_insertion_point(field_list:kaldi_serve.RecognizeResponse.results)
  return results_;
}

// -------------------------------------------------------------------

// RecognitionConfig

// .kaldi_serve.RecognitionConfig.AudioEncoding encoding = 1;
inline void RecognitionConfig::clear_encoding() {
  encoding_ = 0;
}
inline ::kaldi_serve::RecognitionConfig_AudioEncoding RecognitionConfig::encoding() const {
  // @@protoc_insertion_point(field_get:kaldi_serve.RecognitionConfig.encoding)
  return static_cast< ::kaldi_serve::RecognitionConfig_AudioEncoding >(encoding_);
}
inline void RecognitionConfig::set_encoding(::kaldi_serve::RecognitionConfig_AudioEncoding value) {
  
  encoding_ = value;
  // @@protoc_insertion_point(field_set:kaldi_serve.RecognitionConfig.encoding)
}

// int32 sample_rate_hertz = 2;
inline void RecognitionConfig::clear_sample_rate_hertz() {
  sample_rate_hertz_ = 0;
}
inline ::google::protobuf::int32 RecognitionConfig::sample_rate_hertz() const {
  // @@protoc_insertion_point(field_get:kaldi_serve.RecognitionConfig.sample_rate_hertz)
  return sample_rate_hertz_;
}
inline void RecognitionConfig::set_sample_rate_hertz(::google::protobuf::int32 value) {
  
  sample_rate_hertz_ = value;
  // @@protoc_insertion_point(field_set:kaldi_serve.RecognitionConfig.sample_rate_hertz)
}

// string language_code = 3;
inline void RecognitionConfig::clear_language_code() {
  language_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RecognitionConfig::language_code() const {
  // @@protoc_insertion_point(field_get:kaldi_serve.RecognitionConfig.language_code)
  return language_code_.GetNoArena();
}
inline void RecognitionConfig::set_language_code(const ::std::string& value) {
  
  language_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kaldi_serve.RecognitionConfig.language_code)
}
#if LANG_CXX11
inline void RecognitionConfig::set_language_code(::std::string&& value) {
  
  language_code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kaldi_serve.RecognitionConfig.language_code)
}
#endif
inline void RecognitionConfig::set_language_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  language_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kaldi_serve.RecognitionConfig.language_code)
}
inline void RecognitionConfig::set_language_code(const char* value, size_t size) {
  
  language_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kaldi_serve.RecognitionConfig.language_code)
}
inline ::std::string* RecognitionConfig::mutable_language_code() {
  
  // @@protoc_insertion_point(field_mutable:kaldi_serve.RecognitionConfig.language_code)
  return language_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RecognitionConfig::release_language_code() {
  // @@protoc_insertion_point(field_release:kaldi_serve.RecognitionConfig.language_code)
  
  return language_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RecognitionConfig::set_allocated_language_code(::std::string* language_code) {
  if (language_code != nullptr) {
    
  } else {
    
  }
  language_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language_code);
  // @@protoc_insertion_point(field_set_allocated:kaldi_serve.RecognitionConfig.language_code)
}

// int32 max_alternatives = 4;
inline void RecognitionConfig::clear_max_alternatives() {
  max_alternatives_ = 0;
}
inline ::google::protobuf::int32 RecognitionConfig::max_alternatives() const {
  // @@protoc_insertion_point(field_get:kaldi_serve.RecognitionConfig.max_alternatives)
  return max_alternatives_;
}
inline void RecognitionConfig::set_max_alternatives(::google::protobuf::int32 value) {
  
  max_alternatives_ = value;
  // @@protoc_insertion_point(field_set:kaldi_serve.RecognitionConfig.max_alternatives)
}

// bool punctuation = 5;
inline void RecognitionConfig::clear_punctuation() {
  punctuation_ = false;
}
inline bool RecognitionConfig::punctuation() const {
  // @@protoc_insertion_point(field_get:kaldi_serve.RecognitionConfig.punctuation)
  return punctuation_;
}
inline void RecognitionConfig::set_punctuation(bool value) {
  
  punctuation_ = value;
  // @@protoc_insertion_point(field_set:kaldi_serve.RecognitionConfig.punctuation)
}

// repeated .kaldi_serve.SpeechContext speech_contexts = 6;
inline int RecognitionConfig::speech_contexts_size() const {
  return speech_contexts_.size();
}
inline void RecognitionConfig::clear_speech_contexts() {
  speech_contexts_.Clear();
}
inline ::kaldi_serve::SpeechContext* RecognitionConfig::mutable_speech_contexts(int index) {
  // @@protoc_insertion_point(field_mutable:kaldi_serve.RecognitionConfig.speech_contexts)
  return speech_contexts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kaldi_serve::SpeechContext >*
RecognitionConfig::mutable_speech_contexts() {
  // @@protoc_insertion_point(field_mutable_list:kaldi_serve.RecognitionConfig.speech_contexts)
  return &speech_contexts_;
}
inline const ::kaldi_serve::SpeechContext& RecognitionConfig::speech_contexts(int index) const {
  // @@protoc_insertion_point(field_get:kaldi_serve.RecognitionConfig.speech_contexts)
  return speech_contexts_.Get(index);
}
inline ::kaldi_serve::SpeechContext* RecognitionConfig::add_speech_contexts() {
  // @@protoc_insertion_point(field_add:kaldi_serve.RecognitionConfig.speech_contexts)
  return speech_contexts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kaldi_serve::SpeechContext >&
RecognitionConfig::speech_contexts() const {
  // @@protoc_insertion_point(field_list:kaldi_serve.RecognitionConfig.speech_contexts)
  return speech_contexts_;
}

// int32 audio_channel_count = 7;
inline void RecognitionConfig::clear_audio_channel_count() {
  audio_channel_count_ = 0;
}
inline ::google::protobuf::int32 RecognitionConfig::audio_channel_count() const {
  // @@protoc_insertion_point(field_get:kaldi_serve.RecognitionConfig.audio_channel_count)
  return audio_channel_count_;
}
inline void RecognitionConfig::set_audio_channel_count(::google::protobuf::int32 value) {
  
  audio_channel_count_ = value;
  // @@protoc_insertion_point(field_set:kaldi_serve.RecognitionConfig.audio_channel_count)
}

// string model = 10;
inline void RecognitionConfig::clear_model() {
  model_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RecognitionConfig::model() const {
  // @@protoc_insertion_point(field_get:kaldi_serve.RecognitionConfig.model)
  return model_.GetNoArena();
}
inline void RecognitionConfig::set_model(const ::std::string& value) {
  
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kaldi_serve.RecognitionConfig.model)
}
#if LANG_CXX11
inline void RecognitionConfig::set_model(::std::string&& value) {
  
  model_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kaldi_serve.RecognitionConfig.model)
}
#endif
inline void RecognitionConfig::set_model(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kaldi_serve.RecognitionConfig.model)
}
inline void RecognitionConfig::set_model(const char* value, size_t size) {
  
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kaldi_serve.RecognitionConfig.model)
}
inline ::std::string* RecognitionConfig::mutable_model() {
  
  // @@protoc_insertion_point(field_mutable:kaldi_serve.RecognitionConfig.model)
  return model_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RecognitionConfig::release_model() {
  // @@protoc_insertion_point(field_release:kaldi_serve.RecognitionConfig.model)
  
  return model_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RecognitionConfig::set_allocated_model(::std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  model_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model);
  // @@protoc_insertion_point(field_set_allocated:kaldi_serve.RecognitionConfig.model)
}

// bool raw = 11;
inline void RecognitionConfig::clear_raw() {
  raw_ = false;
}
inline bool RecognitionConfig::raw() const {
  // @@protoc_insertion_point(field_get:kaldi_serve.RecognitionConfig.raw)
  return raw_;
}
inline void RecognitionConfig::set_raw(bool value) {
  
  raw_ = value;
  // @@protoc_insertion_point(field_set:kaldi_serve.RecognitionConfig.raw)
}

// int32 data_bytes = 12;
inline void RecognitionConfig::clear_data_bytes() {
  data_bytes_ = 0;
}
inline ::google::protobuf::int32 RecognitionConfig::data_bytes() const {
  // @@protoc_insertion_point(field_get:kaldi_serve.RecognitionConfig.data_bytes)
  return data_bytes_;
}
inline void RecognitionConfig::set_data_bytes(::google::protobuf::int32 value) {
  
  data_bytes_ = value;
  // @@protoc_insertion_point(field_set:kaldi_serve.RecognitionConfig.data_bytes)
}

// bool word_level = 13;
inline void RecognitionConfig::clear_word_level() {
  word_level_ = false;
}
inline bool RecognitionConfig::word_level() const {
  // @@protoc_insertion_point(field_get:kaldi_serve.RecognitionConfig.word_level)
  return word_level_;
}
inline void RecognitionConfig::set_word_level(bool value) {
  
  word_level_ = value;
  // @@protoc_insertion_point(field_set:kaldi_serve.RecognitionConfig.word_level)
}

// -------------------------------------------------------------------

// RecognitionAudio

// bytes content = 1;
inline bool RecognitionAudio::has_content() const {
  return audio_source_case() == kContent;
}
inline void RecognitionAudio::set_has_content() {
  _oneof_case_[0] = kContent;
}
inline void RecognitionAudio::clear_content() {
  if (has_content()) {
    audio_source_.content_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_audio_source();
  }
}
inline const ::std::string& RecognitionAudio::content() const {
  // @@protoc_insertion_point(field_get:kaldi_serve.RecognitionAudio.content)
  if (has_content()) {
    return audio_source_.content_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RecognitionAudio::set_content(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:kaldi_serve.RecognitionAudio.content)
  if (!has_content()) {
    clear_audio_source();
    set_has_content();
    audio_source_.content_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  audio_source_.content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kaldi_serve.RecognitionAudio.content)
}
#if LANG_CXX11
inline void RecognitionAudio::set_content(::std::string&& value) {
  // @@protoc_insertion_point(field_set:kaldi_serve.RecognitionAudio.content)
  if (!has_content()) {
    clear_audio_source();
    set_has_content();
    audio_source_.content_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  audio_source_.content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kaldi_serve.RecognitionAudio.content)
}
#endif
inline void RecognitionAudio::set_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_content()) {
    clear_audio_source();
    set_has_content();
    audio_source_.content_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  audio_source_.content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kaldi_serve.RecognitionAudio.content)
}
inline void RecognitionAudio::set_content(const void* value, size_t size) {
  if (!has_content()) {
    clear_audio_source();
    set_has_content();
    audio_source_.content_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  audio_source_.content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kaldi_serve.RecognitionAudio.content)
}
inline ::std::string* RecognitionAudio::mutable_content() {
  if (!has_content()) {
    clear_audio_source();
    set_has_content();
    audio_source_.content_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:kaldi_serve.RecognitionAudio.content)
  return audio_source_.content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RecognitionAudio::release_content() {
  // @@protoc_insertion_point(field_release:kaldi_serve.RecognitionAudio.content)
  if (has_content()) {
    clear_has_audio_source();
    return audio_source_.content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void RecognitionAudio::set_allocated_content(::std::string* content) {
  if (has_audio_source()) {
    clear_audio_source();
  }
  if (content != nullptr) {
    set_has_content();
    audio_source_.content_.UnsafeSetDefault(content);
  }
  // @@protoc_insertion_point(field_set_allocated:kaldi_serve.RecognitionAudio.content)
}

// string uri = 2;
inline bool RecognitionAudio::has_uri() const {
  return audio_source_case() == kUri;
}
inline void RecognitionAudio::set_has_uri() {
  _oneof_case_[0] = kUri;
}
inline void RecognitionAudio::clear_uri() {
  if (has_uri()) {
    audio_source_.uri_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_audio_source();
  }
}
inline const ::std::string& RecognitionAudio::uri() const {
  // @@protoc_insertion_point(field_get:kaldi_serve.RecognitionAudio.uri)
  if (has_uri()) {
    return audio_source_.uri_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RecognitionAudio::set_uri(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:kaldi_serve.RecognitionAudio.uri)
  if (!has_uri()) {
    clear_audio_source();
    set_has_uri();
    audio_source_.uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  audio_source_.uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kaldi_serve.RecognitionAudio.uri)
}
#if LANG_CXX11
inline void RecognitionAudio::set_uri(::std::string&& value) {
  // @@protoc_insertion_point(field_set:kaldi_serve.RecognitionAudio.uri)
  if (!has_uri()) {
    clear_audio_source();
    set_has_uri();
    audio_source_.uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  audio_source_.uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kaldi_serve.RecognitionAudio.uri)
}
#endif
inline void RecognitionAudio::set_uri(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_uri()) {
    clear_audio_source();
    set_has_uri();
    audio_source_.uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  audio_source_.uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kaldi_serve.RecognitionAudio.uri)
}
inline void RecognitionAudio::set_uri(const char* value, size_t size) {
  if (!has_uri()) {
    clear_audio_source();
    set_has_uri();
    audio_source_.uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  audio_source_.uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kaldi_serve.RecognitionAudio.uri)
}
inline ::std::string* RecognitionAudio::mutable_uri() {
  if (!has_uri()) {
    clear_audio_source();
    set_has_uri();
    audio_source_.uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:kaldi_serve.RecognitionAudio.uri)
  return audio_source_.uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RecognitionAudio::release_uri() {
  // @@protoc_insertion_point(field_release:kaldi_serve.RecognitionAudio.uri)
  if (has_uri()) {
    clear_has_audio_source();
    return audio_source_.uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void RecognitionAudio::set_allocated_uri(::std::string* uri) {
  if (has_audio_source()) {
    clear_audio_source();
  }
  if (uri != nullptr) {
    set_has_uri();
    audio_source_.uri_.UnsafeSetDefault(uri);
  }
  // @@protoc_insertion_point(field_set_allocated:kaldi_serve.RecognitionAudio.uri)
}

inline bool RecognitionAudio::has_audio_source() const {
  return audio_source_case() != AUDIO_SOURCE_NOT_SET;
}
inline void RecognitionAudio::clear_has_audio_source() {
  _oneof_case_[0] = AUDIO_SOURCE_NOT_SET;
}
inline RecognitionAudio::AudioSourceCase RecognitionAudio::audio_source_case() const {
  return RecognitionAudio::AudioSourceCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SpeechRecognitionResult

// repeated .kaldi_serve.SpeechRecognitionAlternative alternatives = 1;
inline int SpeechRecognitionResult::alternatives_size() const {
  return alternatives_.size();
}
inline void SpeechRecognitionResult::clear_alternatives() {
  alternatives_.Clear();
}
inline ::kaldi_serve::SpeechRecognitionAlternative* SpeechRecognitionResult::mutable_alternatives(int index) {
  // @@protoc_insertion_point(field_mutable:kaldi_serve.SpeechRecognitionResult.alternatives)
  return alternatives_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kaldi_serve::SpeechRecognitionAlternative >*
SpeechRecognitionResult::mutable_alternatives() {
  // @@protoc_insertion_point(field_mutable_list:kaldi_serve.SpeechRecognitionResult.alternatives)
  return &alternatives_;
}
inline const ::kaldi_serve::SpeechRecognitionAlternative& SpeechRecognitionResult::alternatives(int index) const {
  // @@protoc_insertion_point(field_get:kaldi_serve.SpeechRecognitionResult.alternatives)
  return alternatives_.Get(index);
}
inline ::kaldi_serve::SpeechRecognitionAlternative* SpeechRecognitionResult::add_alternatives() {
  // @@protoc_insertion_point(field_add:kaldi_serve.SpeechRecognitionResult.alternatives)
  return alternatives_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kaldi_serve::SpeechRecognitionAlternative >&
SpeechRecognitionResult::alternatives() const {
  // @@protoc_insertion_point(field_list:kaldi_serve.SpeechRecognitionResult.alternatives)
  return alternatives_;
}

// -------------------------------------------------------------------

// SpeechRecognitionAlternative

// string transcript = 1;
inline void SpeechRecognitionAlternative::clear_transcript() {
  transcript_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SpeechRecognitionAlternative::transcript() const {
  // @@protoc_insertion_point(field_get:kaldi_serve.SpeechRecognitionAlternative.transcript)
  return transcript_.GetNoArena();
}
inline void SpeechRecognitionAlternative::set_transcript(const ::std::string& value) {
  
  transcript_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kaldi_serve.SpeechRecognitionAlternative.transcript)
}
#if LANG_CXX11
inline void SpeechRecognitionAlternative::set_transcript(::std::string&& value) {
  
  transcript_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kaldi_serve.SpeechRecognitionAlternative.transcript)
}
#endif
inline void SpeechRecognitionAlternative::set_transcript(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  transcript_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kaldi_serve.SpeechRecognitionAlternative.transcript)
}
inline void SpeechRecognitionAlternative::set_transcript(const char* value, size_t size) {
  
  transcript_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kaldi_serve.SpeechRecognitionAlternative.transcript)
}
inline ::std::string* SpeechRecognitionAlternative::mutable_transcript() {
  
  // @@protoc_insertion_point(field_mutable:kaldi_serve.SpeechRecognitionAlternative.transcript)
  return transcript_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpeechRecognitionAlternative::release_transcript() {
  // @@protoc_insertion_point(field_release:kaldi_serve.SpeechRecognitionAlternative.transcript)
  
  return transcript_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpeechRecognitionAlternative::set_allocated_transcript(::std::string* transcript) {
  if (transcript != nullptr) {
    
  } else {
    
  }
  transcript_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transcript);
  // @@protoc_insertion_point(field_set_allocated:kaldi_serve.SpeechRecognitionAlternative.transcript)
}

// float confidence = 2;
inline void SpeechRecognitionAlternative::clear_confidence() {
  confidence_ = 0;
}
inline float SpeechRecognitionAlternative::confidence() const {
  // @@protoc_insertion_point(field_get:kaldi_serve.SpeechRecognitionAlternative.confidence)
  return confidence_;
}
inline void SpeechRecognitionAlternative::set_confidence(float value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:kaldi_serve.SpeechRecognitionAlternative.confidence)
}

// float am_score = 3;
inline void SpeechRecognitionAlternative::clear_am_score() {
  am_score_ = 0;
}
inline float SpeechRecognitionAlternative::am_score() const {
  // @@protoc_insertion_point(field_get:kaldi_serve.SpeechRecognitionAlternative.am_score)
  return am_score_;
}
inline void SpeechRecognitionAlternative::set_am_score(float value) {
  
  am_score_ = value;
  // @@protoc_insertion_point(field_set:kaldi_serve.SpeechRecognitionAlternative.am_score)
}

// float lm_score = 4;
inline void SpeechRecognitionAlternative::clear_lm_score() {
  lm_score_ = 0;
}
inline float SpeechRecognitionAlternative::lm_score() const {
  // @@protoc_insertion_point(field_get:kaldi_serve.SpeechRecognitionAlternative.lm_score)
  return lm_score_;
}
inline void SpeechRecognitionAlternative::set_lm_score(float value) {
  
  lm_score_ = value;
  // @@protoc_insertion_point(field_set:kaldi_serve.SpeechRecognitionAlternative.lm_score)
}

// repeated .kaldi_serve.Word words = 5;
inline int SpeechRecognitionAlternative::words_size() const {
  return words_.size();
}
inline void SpeechRecognitionAlternative::clear_words() {
  words_.Clear();
}
inline ::kaldi_serve::Word* SpeechRecognitionAlternative::mutable_words(int index) {
  // @@protoc_insertion_point(field_mutable:kaldi_serve.SpeechRecognitionAlternative.words)
  return words_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kaldi_serve::Word >*
SpeechRecognitionAlternative::mutable_words() {
  // @@protoc_insertion_point(field_mutable_list:kaldi_serve.SpeechRecognitionAlternative.words)
  return &words_;
}
inline const ::kaldi_serve::Word& SpeechRecognitionAlternative::words(int index) const {
  // @@protoc_insertion_point(field_get:kaldi_serve.SpeechRecognitionAlternative.words)
  return words_.Get(index);
}
inline ::kaldi_serve::Word* SpeechRecognitionAlternative::add_words() {
  // @@protoc_insertion_point(field_add:kaldi_serve.SpeechRecognitionAlternative.words)
  return words_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kaldi_serve::Word >&
SpeechRecognitionAlternative::words() const {
  // @@protoc_insertion_point(field_list:kaldi_serve.SpeechRecognitionAlternative.words)
  return words_;
}

// -------------------------------------------------------------------

// Word

// float start_time = 1;
inline void Word::clear_start_time() {
  start_time_ = 0;
}
inline float Word::start_time() const {
  // @@protoc_insertion_point(field_get:kaldi_serve.Word.start_time)
  return start_time_;
}
inline void Word::set_start_time(float value) {
  
  start_time_ = value;
  // @@protoc_insertion_point(field_set:kaldi_serve.Word.start_time)
}

// float end_time = 2;
inline void Word::clear_end_time() {
  end_time_ = 0;
}
inline float Word::end_time() const {
  // @@protoc_insertion_point(field_get:kaldi_serve.Word.end_time)
  return end_time_;
}
inline void Word::set_end_time(float value) {
  
  end_time_ = value;
  // @@protoc_insertion_point(field_set:kaldi_serve.Word.end_time)
}

// string word = 3;
inline void Word::clear_word() {
  word_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Word::word() const {
  // @@protoc_insertion_point(field_get:kaldi_serve.Word.word)
  return word_.GetNoArena();
}
inline void Word::set_word(const ::std::string& value) {
  
  word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kaldi_serve.Word.word)
}
#if LANG_CXX11
inline void Word::set_word(::std::string&& value) {
  
  word_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kaldi_serve.Word.word)
}
#endif
inline void Word::set_word(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kaldi_serve.Word.word)
}
inline void Word::set_word(const char* value, size_t size) {
  
  word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kaldi_serve.Word.word)
}
inline ::std::string* Word::mutable_word() {
  
  // @@protoc_insertion_point(field_mutable:kaldi_serve.Word.word)
  return word_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Word::release_word() {
  // @@protoc_insertion_point(field_release:kaldi_serve.Word.word)
  
  return word_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Word::set_allocated_word(::std::string* word) {
  if (word != nullptr) {
    
  } else {
    
  }
  word_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), word);
  // @@protoc_insertion_point(field_set_allocated:kaldi_serve.Word.word)
}

// float confidence = 4;
inline void Word::clear_confidence() {
  confidence_ = 0;
}
inline float Word::confidence() const {
  // @@protoc_insertion_point(field_get:kaldi_serve.Word.confidence)
  return confidence_;
}
inline void Word::set_confidence(float value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:kaldi_serve.Word.confidence)
}

// -------------------------------------------------------------------

// SpeechContext

// repeated string phrases = 1;
inline int SpeechContext::phrases_size() const {
  return phrases_.size();
}
inline void SpeechContext::clear_phrases() {
  phrases_.Clear();
}
inline const ::std::string& SpeechContext::phrases(int index) const {
  // @@protoc_insertion_point(field_get:kaldi_serve.SpeechContext.phrases)
  return phrases_.Get(index);
}
inline ::std::string* SpeechContext::mutable_phrases(int index) {
  // @@protoc_insertion_point(field_mutable:kaldi_serve.SpeechContext.phrases)
  return phrases_.Mutable(index);
}
inline void SpeechContext::set_phrases(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:kaldi_serve.SpeechContext.phrases)
  phrases_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SpeechContext::set_phrases(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:kaldi_serve.SpeechContext.phrases)
  phrases_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SpeechContext::set_phrases(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  phrases_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kaldi_serve.SpeechContext.phrases)
}
inline void SpeechContext::set_phrases(int index, const char* value, size_t size) {
  phrases_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kaldi_serve.SpeechContext.phrases)
}
inline ::std::string* SpeechContext::add_phrases() {
  // @@protoc_insertion_point(field_add_mutable:kaldi_serve.SpeechContext.phrases)
  return phrases_.Add();
}
inline void SpeechContext::add_phrases(const ::std::string& value) {
  phrases_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kaldi_serve.SpeechContext.phrases)
}
#if LANG_CXX11
inline void SpeechContext::add_phrases(::std::string&& value) {
  phrases_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kaldi_serve.SpeechContext.phrases)
}
#endif
inline void SpeechContext::add_phrases(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  phrases_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kaldi_serve.SpeechContext.phrases)
}
inline void SpeechContext::add_phrases(const char* value, size_t size) {
  phrases_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kaldi_serve.SpeechContext.phrases)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
SpeechContext::phrases() const {
  // @@protoc_insertion_point(field_list:kaldi_serve.SpeechContext.phrases)
  return phrases_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
SpeechContext::mutable_phrases() {
  // @@protoc_insertion_point(field_mutable_list:kaldi_serve.SpeechContext.phrases)
  return &phrases_;
}

// string type = 2;
inline void SpeechContext::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SpeechContext::type() const {
  // @@protoc_insertion_point(field_get:kaldi_serve.SpeechContext.type)
  return type_.GetNoArena();
}
inline void SpeechContext::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kaldi_serve.SpeechContext.type)
}
#if LANG_CXX11
inline void SpeechContext::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kaldi_serve.SpeechContext.type)
}
#endif
inline void SpeechContext::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kaldi_serve.SpeechContext.type)
}
inline void SpeechContext::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kaldi_serve.SpeechContext.type)
}
inline ::std::string* SpeechContext::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:kaldi_serve.SpeechContext.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpeechContext::release_type() {
  // @@protoc_insertion_point(field_release:kaldi_serve.SpeechContext.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpeechContext::set_allocated_type(::std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:kaldi_serve.SpeechContext.type)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace kaldi_serve

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::kaldi_serve::RecognitionConfig_AudioEncoding> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kaldi_serve::RecognitionConfig_AudioEncoding>() {
  return ::kaldi_serve::RecognitionConfig_AudioEncoding_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_kaldi_5fserve_2eproto
